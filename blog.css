// Unified Blog System - Core Manager
// Thay thế logic cũ trong blog.js và BlogManager class

class UnifiedBlogManager {
  constructor() {
    this.config = {
      sources: [
        {owner:"copgiay86", repo:"anarocafe", branch:"main"},
        {owner:"copgiay86", repo:"anarocafe-vert", branch:"main"},
        {owner:"copgiay86", repo:"anarocafe", branch:"master"},
        {owner:"copgiay86", repo:"anarocafe-vert", branch:"master"},
      ],
      postsDir: "posts",
      postsPerPage: 6,
      cacheExpiry: 5 * 60 * 1000, // 5 minutes
    };

    this.state = {
      posts: [],
      filteredPosts: [],
      currentPage: 1,
      searchQuery: '',
      currentFilter: 'all',
      loading: false,
      error: null,
    };

    this.cache = new Map();
    this.observers = new Set();
    this.init();
  }

  // Event system for state updates
  subscribe(callback) {
    this.observers.add(callback);
    return () => this.observers.delete(callback);
  }

  notify(event, data) {
    this.observers.forEach(callback => {
      try {
        callback(event, data);
      } catch (e) {
        console.warn('Observer error:', e);
      }
    });
  }

  // Unified state management
  setState(updates) {
    const prevState = { ...this.state };
    this.state = { ...this.state, ...updates };
    
    // Auto-update filtered posts when relevant state changes
    if ('posts' in updates || 'searchQuery' in updates || 'currentFilter' in updates) {
      this.updateFilteredPosts();
    }
    
    this.notify('stateChange', { prevState, newState: this.state });
  }

  // Improved caching with expiry
  getCached(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }

  setCached(key, data) {
    this.cache.set(key, {
      data,
      expiry: Date.now() + this.config.cacheExpiry
    });
  }

  // Enhanced error handling
  handleError(error, context = '') {
    const errorInfo = {
      message: error.message,
      context,
      timestamp: new Date().toISOString(),
      type: error.constructor.name
    };

    console.error(`[Blog${context ? ` ${context}` : ''}]`, errorInfo);
    
    this.setState({ 
      error: errorInfo,
      loading: false 
    });

    return errorInfo;
  }

  // Optimized API fetching with retry logic
  async fetchWithRetry(url, options = {}, maxRetries = 3) {
    const cacheKey = `fetch:${url}`;
    const cached = this.getCached(cacheKey);
    if (cached) return cached;

    for (let i = 0; i <= maxRetries; i++) {
      try {
        const response = await fetch(url, {
          headers: {
            "Accept": "application/vnd.github+json",
            "User-Agent": "ANARO-Blog/3.0",
            ...options.headers
          },
          ...options
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = options.text ? await response.text() : await response.json();
        this.setCached(cacheKey, data);
        return data;

      } catch (error) {
        if (i === maxRetries) throw error;
        await this.delay(Math.pow(2, i) * 1000); // Exponential backoff
      }
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Smart source resolution with fallback
  async resolveSource() {
    const cacheKey = 'source:resolved';
    const cached = this.getCached(cacheKey);
    if (cached) return cached;

    const errors = [];
    
    for (const source of this.config.sources) {
      try {
        const listApi = `https://api.github.com/repos/${source.owner}/${source.repo}/contents/${this.config.postsDir}?ref=${source.branch}`;
        const files = await this.fetchWithRetry(listApi);
        
        if (Array.isArray(files)) {
          const mdFiles = files.filter(f => 
            f.type === "file" && /\.md$/i.test(f.name)
          );
          
          if (mdFiles.length > 0) {
            const result = { ...source, files: mdFiles };
            this.setCached(cacheKey, result);
            return result;
          }
        }
      } catch (error) {
        errors.push({ source, error: error.message });
      }
    }

    throw new Error(`No valid sources found. Tried: ${errors.map(e => 
      `${e.source.owner}/${e.source.repo}@${e.source.branch} (${e.error})`
    ).join(', ')}`);
  }

  // Enhanced front matter parsing
  parseFrontMatter(content) {
    const fmRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = content.match(fmRegex);
    
    if (!match) return { meta: {}, body: content };
    
    const [, frontMatter, body] = match;
    const meta = {};
    
    frontMatter.split('\n').forEach(line => {
      const colonIndex = line.indexOf(':');
      if (colonIndex === -1) return;
      
      const key = line.slice(0, colonIndex).trim();
      let value = line.slice(colonIndex + 1).trim();
      
      // Remove quotes
      if ((value.startsWith('"') && value.endsWith('"')) || 
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }
      
      // Type conversion
      if (key.toLowerCase() === 'tags') {
        value = this.parseTags(value);
      } else if (['popular', 'featured'].includes(key.toLowerCase())) {
        value = /^true$/i.test(value);
      } else if (key.toLowerCase() === 'views') {
        value = parseInt(value, 10) || 0;
      }
      
      meta[key] = value;
    });
    
    return { meta, body: body.trim() };
  }

  parseTags(tagString) {
    if (tagString.startsWith('[') && tagString.endsWith(']')) {
      // Array format: [tag1, tag2, tag3]
      return tagString.slice(1, -1)
        .split(',')
        .map(tag => tag.trim().replace(/['"]/g, ''))
        .filter(Boolean);
    } else {
      // Comma-separated format: tag1, tag2, tag3
      return tagString.split(',').map(tag => tag.trim()).filter(Boolean);
    }
  }

  // Optimized post loading with progress tracking
  async loadPosts() {
    if (this.state.loading) return; // Prevent double loading
    
    this.setState({ loading: true, error: null });
    
    try {
      const source = await this.resolveSource();
      const rawBase = `https://raw.githubusercontent.com/${source.owner}/${source.repo}/${source.branch}/`;
      
      const posts = [];
      const total = source.files.length;
      
      // Batch processing for better performance
      const batchSize = 5;
      for (let i = 0; i < source.files.length; i += batchSize) {
        const batch = source.files.slice(i, i + batchSize);
        
        const batchPromises = batch.map(async (file) => {
          try {
            const url = `${rawBase}${this.config.postsDir}/${file.name}`;
            const content = await this.fetchWithRetry(url, { text: true });
            return this.processPost(file, content);
          } catch (error) {
            console.warn(`Failed to load ${file.name}:`, error.message);
            return null;
          }
        });
        
        const batchResults = await Promise.all(batchPromises);
        posts.push(...batchResults.filter(Boolean));
        
        // Progress update
        this.notify('loadProgress', { 
          loaded: Math.min(i + batchSize, total), 
          total 
        });
      }
      
      // Sort posts by date (newest first), then by title
      posts.sort((a, b) => {
        const dateA = new Date(a.date || 0).getTime();
        const dateB = new Date(b.date || 0).getTime();
        
        if (dateA !== dateB) return dateB - dateA;
        return a.title.localeCompare(b.title, 'vi');
      });
      
      this.setState({ 
        posts, 
        loading: false,
        currentPage: 1
      });
      
    } catch (error) {
      this.handleError(error, 'loadPosts');
    }
  }

  // Enhanced post processing
  processPost(file, content) {
    const { meta, body } = this.parseFrontMatter(content);
    const slug = file.name.replace(/\.md$/i, '');
    
    return {
      id: slug,
      slug,
      filename: file.name,
      title: meta.title || this.slugToTitle(slug),
      description: meta.description || this.extractDescription(body),
      content: body,
      date: meta.date || '',
      tags: meta.tags || [],
      cover: meta.cover || '',
      views: meta.views || 0,
      popular: meta.popular || false,
      featured: meta.featured || false,
      
      // Computed properties
      isNew: this.isNewPost(meta.date),
      isHot: this.isPopularPost(meta),
      readTime: this.calculateReadTime(body),
      wordCount: this.countWords(body),
      
      // Store raw meta for extensions
      _meta: meta,
      _raw: content
    };
  }

  slugToTitle(slug) {
    return slug
      .replace(/-/g, ' ')
      .replace(/\b\w/g, l => l.toUpperCase());
  }

  extractDescription(body, maxLength = 160) {
    if (!body) return '';
    
    // Find first paragraph
    const firstPara = body
      .split(/\n\s*\n/)[0]
      ?.replace(/[#>*`_~\-!\[\]\(\)]/g, ' ')
      ?.replace(/\s+/g, ' ')
      ?.trim();
    
    if (!firstPara) return '';
    
    return firstPara.length > maxLength 
      ? firstPara.slice(0, maxLength - 1) + '…'
      : firstPara;
  }

  isNewPost(dateString) {
    if (!dateString) return false;
    const postDate = new Date(dateString);
    const threeWeeksAgo = new Date(Date.now() - 21 * 24 * 60 * 60 * 1000);
    return postDate > threeWeeksAgo;
  }

  isPopularPost(meta) {
    return meta.popular === true || (meta.views && meta.views >= 50);
  }

  calculateReadTime(content) {
    const wordsPerMinute = 200;
    const wordCount = this.countWords(content);
    return Math.max(1, Math.ceil(wordCount / wordsPerMinute));
  }

  countWords(text) {
    return text.trim().split(/\s+/).length;
  }

  // Optimized filtering and search
  updateFilteredPosts() {
    const { posts, searchQuery, currentFilter } = this.state;
    
    let filtered = posts.filter(post => {
      // Search filter
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        const searchableText = [
          post.title,
          post.description,
          ...post.tags
        ].join(' ').toLowerCase();
        
        if (!searchableText.includes(query)) return false;
      }
      
      // Tag filter
      if (currentFilter !== 'all') {
        const hasTag = post.tags.some(tag => 
          tag.toLowerCase() === currentFilter.toLowerCase()
        );
        if (!hasTag) return false;
      }
      
      return true;
    });
    
    this.setState({ 
      filteredPosts: filtered,
      currentPage: 1 // Reset to first page when filtering
    });
  }

  // Public API methods
  search(query) {
    this.setState({ searchQuery: query });
  }

  filterByTag(tag) {
    this.setState({ currentFilter: tag });
  }

  setPage(page) {
    this.setState({ currentPage: page });
  }

  clearFilters() {
    this.setState({
      searchQuery: '',
      currentFilter: 'all',
      currentPage: 1
    });
  }

  // Get paginated posts for display
  getPaginatedPosts() {
    const { filteredPosts, currentPage } = this.state;
    const { postsPerPage } = this.config;
    
    const startIndex = (currentPage - 1) * postsPerPage;
    const endIndex = startIndex + postsPerPage;
    
    return {
      posts: filteredPosts.slice(startIndex, endIndex),
      totalPages: Math.ceil(filteredPosts.length / postsPerPage),
      currentPage,
      hasMore: endIndex < filteredPosts.length,
      totalCount: filteredPosts.length
    };
  }

  // Get post by slug
  getPost(slug) {
    return this.state.posts.find(post => post.slug === slug);
  }

  // Get all unique tags
  getAllTags() {
    const tagCounts = {};
    this.state.posts.forEach(post => {
      post.tags.forEach(tag => {
        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
      });
    });
    
    return Object.entries(tagCounts)
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count);
  }

  // Initialize the manager
  async init() {
    try {
      await this.loadPosts();
    } catch (error) {
      this.handleError(error, 'init');
    }
  }

  // Cleanup method
  destroy() {
    this.observers.clear();
    this.cache.clear();
  }
}

// Export as singleton
window.BlogManager = new UnifiedBlogManager();

// Backward compatibility
window.Blog = {
  // Legacy methods mapped to new API
  renderBlogList: () => window.BlogManager.init(),
  renderSinglePost: (slug) => window.BlogManager.getPost(slug),
  allPosts: () => window.BlogManager.state.posts,
  filterByTag: (tag) => window.BlogManager.filterByTag(tag)
};
